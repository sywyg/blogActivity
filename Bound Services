第二部分bound service


bound service 相当于客户-服务器接口中的服务器。bound service 允许其它组件（除了broadcast receiver）绑定该service，然后进一步操作：发送请求，接收响应，甚至IPC。bound service 只有在其他组件绑定它时才处于存活状态，且会受到绑定它的组件影响。

下面将具体介绍如何创建bound service等相关内容。

#基本知识

若service允许被别的组件绑定的话，我们必须实现`onBind()`方法，该方法将返回一个IBinder对象（在启动方式的service中该方法返回null），以便实现和客户端进行交互。

客户端可以通过调用`bindService()`方法实现绑定，系统会调用服务的`onBind(Intent)`回调方法，返回一个用于和服务进行交互的 IBinder 对象。之后我们必须实现ServiceConnection接口接收IBinder对象，来监控客户端和服务之间的连接。绑定是异步进行的，`bindService()`将立即返回，并不会立即向客户端返回IBinder对象。但是我们可以通过ServiceConnection接口中的方法接收IBinder对象，完成通信。

多个客户端可以绑定同一个service，但是只有第一个才会调用`onBind()`并检索IBinder对象。其它客户端直接接收相同的IBinder对象，而不再调用该方法。

当最后一个客户端解绑service时，系统销毁该service，除非`startService()`方式启动的service。

#创建Bound Service

当创建bound Serivce时，我们必须提供一个IBinder对象，该对象提供了一个编程接口用于和客户端交互。有下列三种方式定义该接口：

- 扩展Binder类
	若service是应用程序私有的，且和客户端在同一个进程中，可以通过这种方式，一般的bound service都是这种方式。客户端得到Binder实例后可以直接实用该类的public方法，甚至可以service类的public方法。

	当我们的service只服务于我们自己的程序时，这种是最好的选择。唯一不使用该方式的原因在于，service被其他应用使用或跨进程。
- 使用Messenger
	若接口要跨进程的工作的话，可以通过Messenger。这种方式，service定义了一个Handler来处理不同的Message对象。对于Messenger来说，Handler是基础，它能够和客户端共享Ibinder，运行客户使用Message发送消息到service。另外，客户端可以定义自己的Messenger来处理service回发的消息。

	这是最简单的方式实现IPC，因为Messenger把所有请求都放在一个线程中，因此不必担心线程安全问题。
- 使用AIDL
	AIDL是Android Interface Definition Language，翻译的话应该是android接口定义语言。AIDL将对象解析为操作系统可识别的原始形态，并将它们跨进程序列化（marshall）以完成IPC（这段翻译的有问题）。使用Messenger也是基于AIDL的，Messenger把所有请求都放在一个线程中，service每次处理一个。然而对于AIDL实现来说。service可以同时处理多个请求。这种情况下，你的服务必须拥有多线程处理能力，并且是以线程安全的方式编写的。

	要直接使用AIDL，你必须创建一个`.aidl`文件，其中定义了编程接口。 Android SDK 工具使用此文件来自动生成一个抽象类，其中实现了接口及对IPC的处理，然后我们就可以在自己的服务中继承该类。

注意：绝大多数应用程序都不应该用AIDL来创建Bound Service，因为这可能需要多线程处理能力并且会让代码变得更为复杂。因此，AIDL对绝大多数应用程序都不适用。

下面详细讲解以上方法（AIDL单独介绍）。

##继承Binder类

如果只是在应用程序内部使用，并且不需要跨进程，我们可以通过这种方式直接进行交互。这种是最常见的方式。

继承Binder类需要完成如下步骤：

1. 在service类中，创建一个Binder对象，该对象可以：
- 包含public方法，客户端直接可以调用；
- 返回当前Service对象，该对象的public方法客户端可以调用；
- 或者返回其它类的对象，该对象能够给客户端提供public方法。
2. 通过在`onBind()`方法中返回该Binder对象。
3. 在客户端通过ServiceConnection接口中的`onServiceConnected()`方法接收该Binder对象，然后就可以调用它的相关方法了。

注意：service和客户端必须在同一个应用程序的原因在于，客户端可以转换返回的Binder对象，然后调用相关方法；service和客户端必须在一个进程中的原因在于，这种方式不执行任何跨进程的序列化（marshalling）。

注：关于marshalling维基上是这样解释的：In computer science, marshalling or marshaling is the process of transforming the memory representation of an object to a data format suitable for storage or transmission, and it is typically used when data must be moved between different parts of a computer program or from one program to another. Marshalling is similar to serialization and is used to communicate to remote objects with an object, in this case a serialized object. It simplifies complex communication, using custom/complex objects to communicate instead of primitives. The opposite, or reverse, of marshalling is called unmarshalling (or demarshalling, similar to deserialization).

根据官方文档中的示例代码修改代码如下：

```java

public class LocalService extends Service {
    // Binder given to clients
    private final IBinder mBinder = new LocalBinder();
    // Random number generator
    private final Random mGenerator = new Random();

    /**
     * Class used for the client Binder.  Because we know this service always
     * runs in the same process as its clients, we don't need to deal with IPC.
     * 在同一进程中通信，并非IPC
     */
    public class LocalBinder extends Binder {
        /**
         * 通过该方法获取LocalService对象
         */
        LocalService getService() {
            // Return this instance of LocalService so clients can call public methods
            Log.d("result","getService executed");
            return LocalService.this;
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        Log.d("result","onBind...");
        return mBinder;
    }

    @Override
    public boolean onUnbind(Intent intent) {
        Log.d("result","onUnbind...");
        return super.onUnbind(intent);
    }

    /**
     * method for clients
     * 模拟客户端需要处理的方法
     */
    public int getRandomNumber() {
        return mGenerator.nextInt(100);
    }
}

```
下面是一个绑定LocalService的activity，当点击按钮是回调`getRandomNumber()`:

```java

public class BindingActivity extends Activity {
    LocalService mService;
    boolean mBound = false;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_binding);
    }

    @Override
    protected void onStart() {
        super.onStart();
        // Bind to LocalService
        //绑定服务
        Intent intent = new Intent(this, LocalService.class);
        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);
    }

    @Override
    protected void onStop() {
        super.onStop();
        // Unbind from the service
        //解除绑定
        if (mBound) {
            unbindService(mConnection);
            mBound = false;
        }
    }

    /** Called when a button is clicked (the button in the layout file attaches to
     * this method with the android:onClick attribute)
     * 客户端处理服务对象业务方法
     */
    public void onButtonClick(View v) {
        if (mBound) {
            // Call a method from the LocalService.
            // However, if this call were something that might hang, then this request should
            // occur in a separate thread to avoid slowing down the activity performance.
            //若耗时则应在一个新的线程中运行
            int num = mService.getRandomNumber();
            Toast.makeText(this, "number: " + num, Toast.LENGTH_SHORT).show();
        }
    }

    /** Defines callbacks for service binding, passed to bindService()
     * 若onBind(Intent intent)方法不返回对象则不调用该ServiceConnection实例
     */
    private ServiceConnection mConnection = new ServiceConnection() {
//执行该方法表示绑定成功，并可以调用服务了。
        @Override
        public void onServiceConnected(ComponentName className,
                                       IBinder service) {
            // We've bound to LocalService, cast the IBinder and get LocalService instance
            LocalService.LocalBinder binder = (LocalService.LocalBinder) service;
            mService = binder.getService();
            Log.d("result", "onServiceConnected...");
            mBound = true;
        }

        @Override
        public void onServiceDisconnected(ComponentName arg0) {
            Log.d("result", "onServiceDisconnected...");
            mBound = false;
        }
    };
}

```
可以看到通过上面这种方式可以实现同一进程间客户端（Client）和Bound Service之间的通信。
局限：客户端与Service必须属于同一个进程，不能实现进程间通信（IPC）。否则会出现类似于`android.os.BinderProxy cannot be cast to xxx`错误。

注：在四大基本组件中，BroadcastReceiver不能作为Bound Service的客户端。因为BroadcastReceiver的生命周期很短，当执行完`onReceive()`回调时，BroadcastReceiver生命周期完结。而Bound Service又与Client本身的生命周期相关，因此，Android中不允许BroadcastReceiver去`bindService()`，当有此类需求时，可以考虑通过`startService()`（四大组件Started Service 都是通过`startService()`）。

##使用Messenger

如果需要远程通信，可以使用一个 Messenger 来提供服务的接口。这种技术能无需使用AIDL就能进行进程间通信（IPC）。
Messenger具体使用步骤如下:

- service中实现一个Handler对象，用于客户端每次调用时处理消息;
- 通过Handler对象创建一个Messenger对象;
- Messenger创建一个IBinder对象，该对象通过`onBind()`方法返回给客户端；
- 客户端使用IBinder对象实例化Messenger（这里指的是service的Handler对象），客户端通过该Handler对象将Message对象发送给service；
- service通过Handler对象接收每个传递的Message，并在`handleMessage()`方法中处理；

这种方式service没有提供给客户端任何方法，而是客户端传递消息（Message对象）给service。

下面是一个简单的使用Messenger的serivce例子：

```java

public class MessengerService extends Service {
    /**
     * Command to the service to display a message
     * 消息标记
     */
    static final int MSG_SAY_HELLO = 1;

    /**
     * Handler of incoming messages from clients.
     * Handler处理客户端发送过来的消息
     */
    class IncomingHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case MSG_SAY_HELLO:
                    Toast.makeText(getApplicationContext(), "hello!", Toast.LENGTH_SHORT).show();
                    break;
                default:
                    super.handleMessage(msg);
            }
        }
    }

    /**
     * Target we publish for clients to send messages to IncomingHandler.
     * Messenger对象
     */
    final Messenger mMessenger = new Messenger(new IncomingHandler());

    /**
     * When binding to the service, we return an interface to our messenger
     * for sending messages to the service.
     */
    @Override
    public IBinder onBind(Intent intent) {
        Toast.makeText(getApplicationContext(), "binding", Toast.LENGTH_SHORT).show();
        return mMessenger.getBinder();
    }
}

```

所有的客户端都需要根据IBinder对象（service传递过来的）创建一个Messenger实例，然后可以通过`send()`发送Message对象。例如下面是一个简单的实现绑定service的例子：

```java

public class ActivityMessenger extends Activity {
    /**
     * Messenger for communicating with the service.
     * Messenger实例
     */
    Messenger mService = null;

    /**
     * Flag indicating whether we have called bind on the service.
     * 标记是否绑定
     */
    boolean mBound;

    /**
     * Class for interacting with the main interface of the service.
     * ServiceConnection接口的实现类
     */
    private ServiceConnection mConnection = new ServiceConnection() {
        public void onServiceConnected(ComponentName className, IBinder service) {
            // This is called when the connection with the service has been
            // established, giving us the object we can use to
            // interact with the service.  We are communicating with the
            // service using a Messenger, so here we get a client-side
            // representation of that from the raw IBinder object.
            // 连接成功时调用该方法，IBinder对象是onBinder方法传递过来的
            mService = new Messenger(service);
            mBound = true;
        }

        public void onServiceDisconnected(ComponentName className) {
            // This is called when the connection with the service has been
            // unexpectedly disconnected -- that is, its process crashed.
            //进程崩溃，连接失败时调用
            mService = null;
            mBound = false;
        }
    };

    /**
     * 按钮事件
     */
    public void sayHello(View v) {
        if (!mBound) return;
        // Create and send a message to the service, using a supported 'what' value
        // 创建Message对象
        Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0);
        try {
        	//发送消息，注意捕获异常
            mService.send(msg);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
    }

    @Override
    protected void onStart() {
        super.onStart();
        // Bind to the service
        // 绑定service
        bindService(new Intent(this, MessengerService.class), mConnection,
            Context.BIND_AUTO_CREATE);
    }

    @Override
    protected void onStop() {
        super.onStop();
        // Unbind from the service
        // 解除绑定
        if (mBound) {
            unbindService(mConnection);
            mBound = false;
        }
    }
}

```

该例子没有展示service如何回应客户端，若是希望回应的话，可以在，，，这里需要写代码验证，，，，，，，，，，，，，，，，
，，，，，，，，，，，，，，，
，，，，，，，，，，，，，，
，，，，，，，，，，，，，，，，
，，，，，，，，，，，，，，
，，，，，，，，，，，，？？
？？？？？？？？？？？？？？
？？？？？？？？？？？？？？

#绑定service

应用程序组件(客户端)能够通过`bindService()`绑定service。然后系统调用service的`onBind()`方法，该方法返回一个IBinder对象用于和service进行交互。

绑定是异步的。`bindService()`会立刻返回，不会返回IBinder对象给客户端。为了接收IBinder对象，客户端必须创建一个ServiceConnection的实例并传递给`bindService()`。ServiceConnection包括一个回调方法，用于接收IBinder对象。

注意：只有activities，services和content providers能够绑定service，broadcast receiver不能绑定。

为了绑定serivce，我们必须完成一下内容：

1. 实现ServiceConnection接口
	必须覆盖两个回调方法：
	`onServiceConnected()`
	连接成功时通过这个方法接收`onBind()`传递的IBinder对象。
	`onServiceDisconnected()`
	意外断开连接时调用，例如当service崩溃或被杀死时。解绑时不会调用。
2. 调用`bindService()`，并且传递ServiceConnection实例；
3. 当系统调用`onServiceConnected()`方法时，可以使用接口中定义的方法和service进行通信；
4. 调用`unBindService()`解除绑定。
	当 客户端被销毁时，它将解绑service，但是我们应该解绑当完成交互时或当service暂停时，这样，service能够在不用时停止。

下面给出了一个简单的例子，实现了ServiceConnection接口：

```java

LocalService mService;
private ServiceConnection mConnection = new ServiceConnection() {
    // Called when the connection with the service is established
    //建立连接时被调用
    public void onServiceConnected(ComponentName className, IBinder service) {
        // Because we have bound to an explicit
        // service that is running in our own process, we can
        // cast its IBinder to a concrete class and directly access it.
        //下面是本地通信（同一个进程中通信）
        LocalBinder binder = (LocalBinder) service;
        mService = binder.getService();
        mBound = true;
    }

    // Called when the connection with the service disconnects unexpectedly
    // 连接失败时调用
    public void onServiceDisconnected(ComponentName className) {
        Log.e(TAG, "onServiceDisconnected");
        mBound = false;
    }
};

```

有了ServiceConnection对象之后，客户端可以通过下列方法绑定service：

```java

Intent intent = new Intent(this,LocalService.class);
bindService(intent,mConnection,Context.BIND_AUTO_CREATE);

```
方法参数分别为：

- 显示启动service的intent(隐士的也可以);
- ServiceConnection实例;
- 标记，用于指示绑定的选择，BIND_AUTO_CREATE表示在service没启动时自动自动，还可以有其它值： BIND_DEBUG_UNBIND（调试解绑时的问题）BIND_NOT_FOREGROUND（阻止当前service的进程提高优先级），0 （none）。

##其它信息

关于绑定还有下面一些重要的提示：

- 需要在连接断开时捕获DeadObjectException异常。这是远程方法中抛出的唯一异常。
- 对象时跨进程统计的参考？？神马意思？？？
- 绑定和解绑要在合适的位置进行：
	
	- 若只有当activity可见时才和service进行交互，则须在`onStart()`方法中绑定，在`onStop()`中解绑；
	- 若即使activity停止时，我们仍想要activity接收响应，则我们可以在`onCreate()`中绑定，在`onDestroy()`中解绑。此时就要多加小心：当前activity需要在整个生命周期中使用service，因此若service在另一个进程中，这种方式增加了该进程被系统杀死的可能性。

注意：不要在activity中的`onResume()`中绑定和在`onPause()`中解绑，这是因为两个方法会在每次生命周期转换的过程中，应该将这些处理在转换时降到最低。同时，若多个activities中绑定了同一个service，并且在这些acitivities中相互转换的话，service会被频繁地销毁重建（在停止时解绑然后被销毁，该动作发生在另一个activity绑定它之前）。

#管理生命周期

当service被所有客户端解绑时，系统销毁该service，除非该service先是被started方法的。因此对于存粹绑定的service我们无需管理它的生命周期--系统基于是否绑定客户端来管理。

若你实现了`onStartCommand()`方法，则此时service被认为是sstarted方式的，因此我们必须管理它的生命周期。在这种情况下，无论是否绑定了客户端，只要调用了stop方法就会service停止。

此外，如果service是started方式，然后被绑定，那么当系统调用`onUnbind()`方法时，如果我们想要接收`onRebind()`方法的回调（下一次客户端绑定该service）而不是接收`onBind()`方法的回调，则我们可以返回true。`onRebind()`方法没有返回值，但是客户端仍然可以接受IBinder对象。这种生命周期的逻辑如下：

图。。。。。。。。。。。。。。。。。。
。。。。。。。。。。。。。。。。。。。。。。
。。。。。。。。。。。。。。
。。。。。。。。。。。。。。。。。。。。。
。。。。。。。。。。。。。。。。。。。。。。
。。。。。。。。。。。。。。。。。。。。
。。。。。。。。。。。。。。。。。。。。。
。。。。。。。。。。。。。。。。。。
。。。。。。。。。。。。。。。。。。。。。
